% bule2 --solve --models 0 constraints.bul models/

% Generate the grid from the width

::width[W]:: coordinate[0..W - 1].
::coordinate[I], coordinate[J]:: grid[c(I, J)].

% Rule for adjacent spots on the grid top and to the right
% ::grid[c(I, J)], grid[c(I, J + 1)]:: adjacent[c(I,J), c(I, J + 1)].
% ::grid[c(I, J)], grid[c(I + 1, J)]:: adjacent[c(I,J), c(I + 1, J)].

% Rule for adjacent spots on the grid bottom and to the left
% ::grid[c(I, J)], grid[c(I, J - 1)]:: adjacent[c(I,J), c(I, J - 1)].
% ::grid[c(I, J)], grid[c(I - 1, J)]:: adjacent[c(I,J), c(I - 1, J)].
% ::adjacent[X, Y]:: adjacent[Y, X]. 

::coordinate[I], coordinate[I + 1]:: nextCoordinate[I, I + 1]. % Having coordinate[I + 1] ensures that I is less than width, so that nextCoordinate[I, I + 1] has (I, I + 1) as valid coordinates
::coordinate[I], coordinate[I - 1]:: nextCoordinate[I, I - 1]. % Having coordinate[I - 1] ensures same thing as above
::coordinate[I], nextCoordinate[J, K]:: adjacent[c(I, J), c(I, K)].
::coordinate[I], nextCoordinate[J, K]:: adjacent[c(J, I), c(K, I)].
% ::coordinate[I], width[W], 0 <= I + 1 < W:: nextCoordinate[I, I + 1]. % Having coordinate[I + 1] ensures that I is less than width, so that nextCoordinate[I, I + 1] has (I, I + 1) as valid coordinates

% 2D coordinates for the grid, adding the c makes the indexing one variable
% ::width[W]:: grid[c(0..W, 0..W)].

% ::grid[G]:: showGrid(G).
% ::coordinate[C]:: coordinate(C).
% ::nextCoordinate[C, D]:: coordinate(C, D).
% ::adjacent[G1, G2]:: #exists[0] showAdjacent(G1, G2).
% ::adjacent[G1, G2]:: #hide ~showAdjacent(G1, G2).
% ::adjacent[G1, G2]:: #hide showAdjacent(G1, G2).
% ::showAdjacent[G1, G2]:: showAdjacent(G1, G2).

% Ensuring Legal Embeddings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% If x(i, j) is true, then the character at position i in the sequence is 
% assigned to point j in the grid
::sequence[I, B], grid[G]:: #exists[0] x(I, G).
::sequence[I, B], grid[G]:: #hide ~x(I, G).

% Every character in the sequence is assigned to some point in G
::sequence[I, B]:: :grid[G]: x(I, G).

% No character-position in the sequence can be assigned to more than one point
::sequence[I, B], grid[G1], grid[G2], G1 != G2:: ~x(I, G1) | ~x(I, G2).

% No point in the grid can have more than one character-position assigned to it
::grid[G], sequence[I1, B1], sequence[I2, B2], I1 != I2:: ~x(I1, G) | ~x(I2, G).

% Every adjacent pair of character positions must be placed on adjacent points in the grid
::sequence[I, B1], sequence[I + 1, B2], grid[G1]:: ~x(I, G1) | :grid[G2], adjacent[G1, G2]: x(I + 1, G2).

% Identifying Potential Contacts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
::grid[G]:: #exists[0] t(G).
::grid[G]:: #hide ~t(G).
% ::grid[G]:: #hide t(G).

% A G, A I, (x(I, G) and sequence(I, 1)) -> T(G)
% A G, A I, (x(I, G) and sequence(I, 0)) -> ~T(G)
% A G, A I, ~x(I, G) -> ~T(G)

% -> can only be used for clauses, where hypothesis is conjunciton and conclusion is disjunction
::grid[G], sequence[I, 1]:: x(I, G) -> t(G).
::grid[G], sequence[I, 0]:: x(I, G) -> ~t(G).
::grid[G]:: :sequence[I, B]: x(I, G) | ~t(G). % For all I, G if x(I, G) is false -> t(G) has to be true


% % t(G) is true iff grid(G) has a character there and it is "1"
% ::t[G1], x[S, G2], G1 == G2:: ~x(S, G2) |  t(G1).
% ::t[G1], x[S, G2], G1 == G2::  x(S, G2) | ~t(G1).

% ::t[G1], x[S1, G2], sequence[S2], G1 == G2, S1 == S2:: ~sequence(S1) |  t(G1).
% ::t[G1], x[S1, G2], sequence[S2], G1 == G2, S1 == S2::  sequence(S1) | ~t(G1).

% ::x[I, G], sequence[I, B]

% % ::t[G1], x[S1, G2], sequence[S2], G1 == G2, S1 == S2:: ~sequence(S1) |  t(G1).
% % ::t[G1], x[S1, G2], sequence[S2], G1 == G2, S1 == S2::  sequence(S1) | ~t(G1).

% % c(G1, G2) is true iff "1" is assigned to t(G1) and t(G2)
% ::adjacent[G1, G2]:: #exists[0] contact(G1, G2).
% ::adjacent[G1, G2]:: #hide ~contact(G1, G2).
% ::adjacent[G1, G2]:: #hide contact(G1, G2).

% ::adjacent[G1, G2]:: ~contact(G1, G2) |  t(G1).
% ::adjacent[G1, G2]:: ~contact(G1, G2) |  t(G2).
% ::adjacent[G1, G2]::  contact(G1, G2) | ~t(G1) | ~t(G2).

% Counting Potential Contacts
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
